\label{sec:algoritmo}

À hora de construir um algoritmo para sistemas distribuídos, é importante ter os três fatores em mente que podem limitar o desempenho da calculação: a CPU, a memoria e a rede que conecta os CPUs. Nesta seção, um algoritmo será discutido que pretende ser eficiente tanto na calculação como na gestão e o acesso à memoria. Uma extensão para executá-lo em paralelo com MPI (\textit{Message Passing Interface}) segue na próxima seção \ref{sec:distribuicao}.\\

A representação em figura \ref{fig:representacao} foi escolhido para ter o máximo de células junto com à vizinhança necessária para o seu processamento em um registro de CPUs da arquitetura 32 bit. Como quase todas as maquinas hoje em dia usadas possuem registros de 64 bit ou tamanhos ainda maiores, a versão atual poderá ser melhorada usando unidades com mais células e uma proporção melhor entre células e vizinhança.\\

O armazenamento de figura \ref{fig:representacao} exige um processamento em duas etapas: primeiro a atualização das células e por segundo a atualização da vizinhança. O primeiro passo pode ser feito de duas maneiras diferentes: com contagens da vizinhança de uma cada das doze células ou usando uma LUT que pode considerar mais que uma bactéria à vez sem necessidade diferenciação de diferentes casos. Considerou-se a segunda possibilidade vantajosa.\\

Usa-se uma LUT de tamanho $2^{3*6}/2$ byte. Ela tem como entrada 18 bit (três linhas de 6 bit, por exemplo os \textit{bits} 0-17)  para calcular o estado de 4 células (por exemplo \textit{bits} 7-10), quer isto dizer que cada unidade de 3 por 4 células pode ser calculada em três acessos à LUT. Pode-se destacar que isso é processo altamente paralela (não há dependências entres as unidades) e pode, portanto, ser acelerado por vetorização bem como utilizado também para arquiteturas de tipo SIMD como GPUs.\\

Na segunda etapa, as vizinhas precisam ser atualizadas. Esse passo só é necessário em caso de mudança das unidades de 32 bit que tem sido marcados anteriormente na primeira etapa. Em caso de mudança, prolifera-se esta informação para os oito unidades vizinhas. Um bordo de células sem informação para evite um tratamento separado dos dados nos extremos do tabuleiro. Também este passo possui um grau alto de paralelismo mesmo que se acessem os mesmos dados mais que uma vez. Tal como na primeira, a ordem do tratamento das dados pode ser variado, ou seja células laterais podem ser tratados antes das interiores sem afetar o resultado do algoritmo. Essa propriedade pode ser usado para ocultar latência em na transmissão de dados, como será explicado na seção \ref{sec:distribuicao}.\\